[{"path":"https://ddebeer.github.io/permimp/articles/permimp-package.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"The permimp-package","text":"Although originally designed prediction purposes, Random forests Breiman (2001) become popular tool assess importance predictors. Several methods measures proposed, one popular ones Permutation Importance Breiman (2001), originally referred Mean Decrease Accuracy. Inspired contrast unconditional zero-order correlation predictor outcome, conditional standardized regression coefficient multiple linear regression, Strobl et al. (2008) argued cases importance predictor, conditionally () predictors, may higher interest unconditional importance. Therefore, proposed Conditional Permutation Importance, introduces conditional permutation scheme based dependence predictors. permimp-package presents different implementation Conditional Permutation Importance. Unlike original implementation (available party R-package Hothorn, Hornik, Zeileis (2006)), permimp can, addition random forests grown according unbiased recursive partitioning (cf. cforests; Hothorn, Hornik, Zeileis (2006)), also deal random forests grown using randomForest-package Liaw Wiener (2002), applies original tree growing algorithm based impurity reduction Breiman (2001). (principle, permimp can extended random forests grown packages, condition tree-wise predictions possible OOB-information well split points available per tree.) argue permimp-package can seen replacement varimp-functions party package R. vignette two main parts. first part tutorial-like demonstrates functionality permimp-package (also comparing original party::varimp-functions. second part theoretical explains new Conditional Permutation Importance-implementation.","code":""},{"path":[]},{"path":"https://ddebeer.github.io/permimp/articles/permimp-package.html","id":"a--the-permimp-function","dir":"Articles","previous_headings":"Part I: permimp-tutorial","what":"A. The permimp-function","title":"The permimp-package","text":"permimp-function replaces party::varimp-functions (varimp, varimpAUC, varimpsurv). apply permimp-function, one needs fitted random forest. Within tutorial mainly focus random forests-objects obtained party::cforest-function (.e., S4-objects class \"RandomForest\"). example use (cleaned) airquality-data set fit random forest 50 trees:","code":"library(\"party\", quietly = TRUE) #>  #> Attaching package: 'zoo' #> The following objects are masked from 'package:base': #>  #>     as.Date, as.Date.numeric library(\"permimp\") set.seed(542863) airq <- subset(airquality, !(is.na(Ozone) | is.na(Solar.R))) cfAirq50 <- cforest(Ozone ~ ., data = airq,                     control = cforest_unbiased(mtry = 2, ntree = 50,                                               minbucket = 5,                                                minsplit = 10))"},{"path":"https://ddebeer.github.io/permimp/articles/permimp-package.html","id":"a-1--new-conditional-permutation-importance","dir":"Articles","previous_headings":"Part I: permimp-tutorial > A. The permimp-function","what":"A.1. New Conditional Permutation Importance","title":"The permimp-package","text":"Let’s start comparing permimp varimp function conditional permutation importance. Three differences can easily spotted: permimp progressBar-argument. default progressBar = interactive()1 permimp faster varimp. results different.","code":"system.time(CPI_permimp <- permimp(cfAirq50, conditional = TRUE, progressBar = FALSE)) #>    user  system elapsed  #>   0.183   0.011   0.194 system.time(CPI_varimp <- varimp(cfAirq50, conditional = TRUE)) #>    user  system elapsed  #>   1.285   0.011   1.296 CPI_permimp #>    Solar.R       Wind       Temp      Month        Day  #>  83.736656 209.786231 422.671385   1.820496  -7.668462 CPI_varimp #>    Solar.R       Wind       Temp      Month        Day  #>  25.147792 114.250197 220.080351   1.952776  -1.265111"},{"path":"https://ddebeer.github.io/permimp/articles/permimp-package.html","id":"a-2--different-results","dir":"Articles","previous_headings":"Part I: permimp-tutorial > A. The permimp-function","what":"A.2. Different results?","title":"The permimp-package","text":"results different? two main reasons. First, permimp uses different default threshold-value: permimp uses threshold = .95 varimp uses threshold = 0.2. Check ?permimp ?varimp. good reason using higher default threshold value. using equal threshold-values… results similar, quite identical. remaining differences explained second reason: implementation permimp differs varimp-implementation. Using higher threshold-value makes differences two implementations pronounced. differences two implementations (believe new implementation attractive), explained second part document, well manuscript: Debeer Strobl (2020).","code":"CPI_permimp <- permimp(cfAirq50, conditional = TRUE, threshold = .2, progressBar = FALSE) CPI_permimp #>     Solar.R        Wind        Temp       Month         Day  #>  26.9974775 122.2781497 204.0238116  -3.1201748   0.8442593 CPI_varimp #>    Solar.R       Wind       Temp      Month        Day  #>  25.147792 114.250197 220.080351   1.952776  -1.265111 CPI_varimp <- varimp(cfAirq50, conditional = TRUE, threshold = .95) CPI_permimp #>     Solar.R        Wind        Temp       Month         Day  #>  26.9974775 122.2781497 204.0238116  -3.1201748   0.8442593 CPI_varimp #>    Solar.R       Wind       Temp      Month        Day  #>  36.758973 198.610059 257.916926  -2.537016  -2.530303"},{"path":"https://ddebeer.github.io/permimp/articles/permimp-package.html","id":"a-3--backward-compatible-with-party-when-asparty-true","dir":"Articles","previous_headings":"Part I: permimp-tutorial > A. The permimp-function","what":"A.3. Backward Compatible with party when: asParty = TRUE","title":"The permimp-package","text":"specifying asParty = TRUE, permimp-function can made backward compatible party::varimp-function. permimp bit faster. get exactly results, random seeds exactly . Note asParty = TRUE default threshold-value automatically set back 0.2.","code":"set.seed(542863) system.time(CPI_asParty <- permimp(cfAirq50, conditional = TRUE, asParty = TRUE, progressBar = FALSE)) #>    user  system elapsed  #>   0.262   0.000   0.263 set.seed(542863) system.time(CPI_varimp <- varimp(cfAirq50, conditional = TRUE)) #>    user  system elapsed  #>   1.266   0.000   1.266 CPI_asParty #>    Solar.R       Wind       Temp      Month        Day  #>  36.364271 136.732886 200.620728   3.179600   1.360632 CPI_varimp #>    Solar.R       Wind       Temp      Month        Day  #>  36.364271 136.732886 200.620728   3.179600   1.360632"},{"path":"https://ddebeer.github.io/permimp/articles/permimp-package.html","id":"a-4--different-output-varimp-object","dir":"Articles","previous_headings":"Part I: permimp-tutorial > A. The permimp-function","what":"A.4. Different Output: VarImp-object","title":"The permimp-package","text":"less obvious difference permimp varimp object returns. permimp returns S3-class object: VarImp, rather named numerical vector. VarImp object named list four elements: $values: holds computed variable importance values. $perTree: holds variable importance values per tree (averaged permutations nperm > 1). $type: type variable importance. $info: relevant information variable importance, used threshold. advantage VarImp-object, $perTree-values can used inspect distribution importance values across trees forest. instance, plotting function (demonstrated ) can used visualize distribution per tree importance values.","code":"## varimp returns a named numerical vector. str(CPI_varimp) #>  Named num [1:5] 36.36 136.73 200.62 3.18 1.36 #>  - attr(*, \"names\")= chr [1:5] \"Solar.R\" \"Wind\" \"Temp\" \"Month\" ...  ## permimp returns a VarImp-object. str(CPI_asParty) #> List of 4 #>  $ values : Named num [1:5] 36.36 136.73 200.62 3.18 1.36 #>   ..- attr(*, \"names\")= chr [1:5] \"Solar.R\" \"Wind\" \"Temp\" \"Month\" ... #>  $ perTree:'data.frame': 50 obs. of  5 variables: #>   ..$ Solar.R: num [1:50] 117.35 0 1.81 0 58.22 ... #>   ..$ Wind   : num [1:50] 118.8 430.7 141.5 171 78.1 ... #>   ..$ Temp   : num [1:50] 374 433 118 -1 175 ... #>   ..$ Month  : num [1:50] -4.59 0 34.93 -11.96 -11.9 ... #>   ..$ Day    : num [1:50] 0 18.93 0 7.18 0 ... #>  $ type   : chr \"Conditional Permutation\" #>  $ info   :List of 4 #>   ..$ threshold   : num 0.2 #>   ..$ conditioning: chr \"as party\" #>   ..$ outcomeType : chr \"regression\" #>   ..$ errorType   : chr \"MSE\" #>  - attr(*, \"class\")= chr \"VarImp\"  ## the results of permimp(asParty = TRUE) and varimp() are exactly the same. all(CPI_asParty$values == CPI_varimp) #> [1] TRUE"},{"path":"https://ddebeer.github.io/permimp/articles/permimp-package.html","id":"a-5--unconditional-permutation-importance-permimp-varimp","dir":"Articles","previous_headings":"Part I: permimp-tutorial > A. The permimp-function","what":"A.5. Unconditional Permutation Importance: permimp = varimp","title":"The permimp-package","text":"course, also option compute unconditional permutation importance. using original split wise permutation algorithm. , differences permimp varimp. , permimp simply uses party varimp code, making asParty argument redundant case. Note, however, permimp still returns VarImp-object. Note argument oldSeedSelection = TRUE added using permimp. Since release version 1.1-0, way random seeds used changed. Choosing oldSeedSelection = TRUE makes computations backward compatible older releases. However, using parallel processing old selection random seeds holds problems reproducible results. Hence, recommend use default oldSeedSelection = FALSE, especially using parallel processing. detailed information check ?permimp.","code":"## Original Unconditional Permutation Importance set.seed(542863) PI_permimp <- permimp(cfAirq50, progressBar = FALSE, pre1.0_0 = TRUE) set.seed(542863) PI_varimp <- varimp(cfAirq50, pre1.0_0 = TRUE) PI_permimp #>      Solar.R         Wind         Temp        Month          Day  #> 104.19612764 345.36320352 582.09815801  18.04859049   0.01880503 PI_varimp #>      Solar.R         Wind         Temp        Month          Day  #> 104.19612764 345.36320352 582.09815801  18.04859049   0.01880503  ## Splitwise Unconditional Permutation Importance set.seed(542863) PI_permimp2 <- permimp(cfAirq50, progressBar = FALSE, oldSeedSelection = TRUE) set.seed(542863) PI_varimp2 <- varimp(cfAirq50) PI_permimp2 #>    Solar.R       Wind       Temp      Month        Day  #>  81.935250 451.459770 580.918085  21.851431  -4.613963 PI_varimp2 #>    Solar.R       Wind       Temp      Month        Day  #>  81.935250 451.459770 580.918085  21.851431  -4.613963"},{"path":[]},{"path":"https://ddebeer.github.io/permimp/articles/permimp-package.html","id":"b-1--plot","dir":"Articles","previous_headings":"Part I: permimp-tutorial > B. Methods for VarImp-objects","what":"B.1. plot","title":"The permimp-package","text":"Visualizing variable importance values (VarImp-object) easy using plot method. main features include: Four plot types:`type = c(“bar”, “box”, “dot”, “rank”). Predictors automatically ordered according importance value (high low). Setting argument sort = FALSE renders original order (cf. cforest call). argument horizontal = TRUE horizontal plots made. Optional visualization $perTree importance value distribution interval argument. type = \"box\", distribution $perTree-values automatically visualized.2 suggest use visualization $perTree importance value distribution, enough trees (>= 500) random forest. Therefore, first fit new, bigger random forest, compute permutation importance.","code":"## fit a new forest with 500 trees set.seed(542863) cfAirq500 <- cforest(Ozone ~ ., data = airq,                      control = cforest_unbiased(mtry = 2, ntree = 500,                                               minbucket = 5,                                                minsplit = 10))  ## compute permutation importance PI_permimp500 <- permimp(cfAirq500, progressBar = FALSE)  ## different plots, all easy to make ## barplot plot(PI_permimp500, type = \"bar\") ## barplot with visualization of the distribution: an ## interval between the .25 and .75 quantiles of the per  ## Tree values is added to the plot plot(PI_permimp500, type = \"bar\", interval = \"quantile\") ## horizontal boxplot plot(PI_permimp500, type = \"box\", horizontal = TRUE) ## unsorted-dotplot plot(PI_permimp500, type = \"dot\", sort = FALSE,       interval = \"quantile\")"},{"path":"https://ddebeer.github.io/permimp/articles/permimp-package.html","id":"additionally-you-can","dir":"Articles","previous_headings":"","what":"The permimp-package","title":"The permimp-package","text":"Use favorite colors arguments col intervalColor. Use different quantile interval intervalProbs = c(<lower_quantile>, <upper_quantile>).3 Choose title title main Modify margin margin.","code":""},{"path":"https://ddebeer.github.io/permimp/articles/permimp-package.html","id":"although-we-would-advise-against-this-in-most-situations-you-can-also","dir":"Articles","previous_headings":"Part I: permimp-tutorial > B. Methods for VarImp-objects > B.1. plot","what":"Although we would advise against this in most situations, you can also:","title":"The permimp-package","text":"Plot <integer value> predictors highest values nVar = <integer value>. Visualize distribution using standard deviation perTree values interval = \"sd\". almost always bad idea, falsely suggests distribution symmetric. Please don’t use option. detailed information check ?plot.VarImp.","code":""},{"path":"https://ddebeer.github.io/permimp/articles/permimp-package.html","id":"b-2--other-varimp-methods","dir":"Articles","previous_headings":"Part I: permimp-tutorial > B. Methods for VarImp-objects","what":"B.2. Other VarImp-methods","title":"The permimp-package","text":"(Currently) three VarImp-methods: print: prints $values ranks: prints (reverse) rankings $values subset: creates subset also aVarImp-object. used limited settings, know . related functions : .VarImp: creates VarImp-object matrix/data.frame perTree values, numerical vector importance values. .VarImp: checks object VarImp-class.","code":""},{"path":"https://ddebeer.github.io/permimp/articles/permimp-package.html","id":"c--permimp-applied-to-randomforest-objects","dir":"Articles","previous_headings":"Part I: permimp-tutorial","what":"C. permimp applied to randomForest-objects","title":"The permimp-package","text":"mentioned introduction, permimp-package can also deal random forests grown using randomForest-package Liaw Wiener (2002), applies original tree growing algorithm based impurity reduction Breiman (2001). Let’s first grow (small) forest. Note keep.forest = TRUE keep.inbag = TRUE. permimp-function requires information observations -bag (IB) --bag (OOB), well information split points tree. Without information, (Conditional) Permutation Importance algorithm executed.  calling permimp randomForest object form randomForest-package, menu prompted ask whether sure data-objects used fit random forest changed. permimp computations rely data-objects, automatically search environment. data-objects changed, permimp results can distorted.","code":"library(\"randomForest\", quietly = TRUE) #> randomForest 4.7-1.2 #> Type rfNews() to see new features/changes/bug fixes. set.seed(542863) rfAirq50 <- randomForest(Ozone ~ ., data = airq, mtry = 2, replace = FALSE,                           nodesize = 7, keep.forest = TRUE, keep.inbag = TRUE) CPI_permimpRF <- permimp(rfAirq50, conditional = TRUE, progressBar = FALSE) plot(CPI_permimpRF, horizontal = TRUE)"},{"path":"https://ddebeer.github.io/permimp/articles/permimp-package.html","id":"part-ii-new-conditional-permutation-implementation","dir":"Articles","previous_headings":"","what":"Part II: New Conditional Permutation Implementation","title":"The permimp-package","text":"part explains new implementation conditional permutation importance, discusses differences original implementation party, described Strobl et al. (2008). First idea behind conditional implementation briefly recapitulated, followed discussion original implementation. new implementation explained, main differences original emphasized. Finally, practical implications new implementation given, interpretation possible use threshold value discussed.","code":""},{"path":"https://ddebeer.github.io/permimp/articles/permimp-package.html","id":"a--recapitulation-conditional-permutation-importance-","dir":"Articles","previous_headings":"Part II: New Conditional Permutation Implementation","what":"A. Recapitulation: Conditional Permutation Importance.","title":"The permimp-package","text":"researcher may interested whether predictor XX outcome YY independent. “null-hypothesis” P(Y|X)=P(Y)P(Y | X) = P(Y). corresponds unconditional permutation importance. XX YY indeed independent, permuting XX significantly change prediction accuracy tree/forest. expected permutation importance value zero. However, researcher may also interested conditional independence XX YY, conditionally values predictors ZZ. “null-hypothesis” P(Y|X,Z)=P(Y|Z)P(Y | X, Z) = P(Y | Z). Rather “completely” permuting XX values, XX values can permuted conditionally, given corresponding ZZ values. corresponds conditional permutation scheme. XX YY conditionally independent, ideally, conditional importance measure zero. XX ZZ independent, permutation schemes give results. practice, similar importance values. Yet dependence XX ZZ result differences unconditional conditional permutation schemes, corresponding importance values. Strobl et al. (2008) proposed specify partitioning (grid) predictor space based ZZ (tree), order (conditionally) permute values XX withing partition (.e., cell grid). According Strobl et al. (2008) partitioning (1) applicable variables types; (2) parsimonious possible, (3) also computationally feasible. Therefore suggested define partitioning grid tree means partitions predictor space induced tree. precisely, using split points ZZ tree, ZZ discretized complete predictor space partitioned using discretized ZZ. Note partitioning correspond recursive partitioning tree. tree top node splits complete predictor space, following splits conditional parent nodes. contrast, conditional permutation grid, split points split complete predictor space, leads fine-grained grid. practice, number observations finite. situation relatively low number observations, grid conditional permutation may become fine grained, making conditionally permuting practically infeasible. Therefore, selection ZZ (predictors condition ) sinecure.","code":""},{"path":"https://ddebeer.github.io/permimp/articles/permimp-package.html","id":"b--original-implementation-partyvarimp","dir":"Articles","previous_headings":"Part II: New Conditional Permutation Implementation","what":"B. Original Implementation (party::varimp)","title":"The permimp-package","text":"original implementation (cf, party::varimp), Strobl et al. (2008) argued include variables ZZ whose empirical correlation XX exceeds certain moderate threshold. continuous variables Pearson correlation used, general case proposed use conditional inference framework promoted Hothorn, Hornik, Zeileis (2006). Applying framework provides p-values, advantage comparable variables types, can serve intuitive objective means selecting variables Z condition . original implementation can described follows: every predictor XX Test predictors related XX, applying conditional inference framework (Hothorn et al. 2006) using full data/training set. include predictors ZZ pp-value test smaller (1 - threshold). Gather split points every predictor ZZ. Discretize predictors ZZ using gathered split points, create partitioning predictor space. Within partition, permute values predictor XX.","code":""},{"path":"https://ddebeer.github.io/permimp/articles/permimp-package.html","id":"some-issues","dir":"Articles","previous_headings":"Part II: New Conditional Permutation Implementation > B. Original Implementation (party::varimp)","what":"Some issues","title":"The permimp-package","text":", however, two important issues implementation: () tests conditional inference framework, pp-values depend strength (cor)relation, also sample size. instance, big samples small correlations can also lead small pp-values. (tests ) conditional inference framework test linear dependence. instance, continuous variables correlation test used. course, dependence variables limited linear dependence. result, XX WW continuous U-shaped independence structure, WW included ZZ.","code":""},{"path":"https://ddebeer.github.io/permimp/articles/permimp-package.html","id":"c--new-implementation-permimp-","dir":"Articles","previous_headings":"Part II: New Conditional Permutation Implementation","what":"C. New Implementation (permimp).","title":"The permimp-package","text":"new implementation tries mitigate two issues raised , taking advantage fact within tree original values predictors, partitions important prediction outcome. , one can argue tree-based partitioning rather original values used decide predictors included ZZ. Applying rationale, new implementation can described follows: every tree, every predictor splits tree: Discretize -bag values predictor using split points: XX => XdX_d. every discretized XdX_d: Test discretized predictors WdW_d related XdX_d, applying χ2\\chi^2-independence tests (using -bag values). include predictors WW ZZ pp-value test smaller (1 - threshold). Create partitioning predictor space using discretized ZZ. Within partition, permute values predictor XX.","code":""},{"path":"https://ddebeer.github.io/permimp/articles/permimp-package.html","id":"important-implications","dir":"Articles","previous_headings":"Part II: New Conditional Permutation Implementation > C. New Implementation (permimp).","what":"Important implications","title":"The permimp-package","text":"χ2\\chi^2-independence test (directly) depend sample size. Therefore, new implementation less sensitive number observations. addition, χ2\\chi^2-independence test limited linear dependence. Hence, new implementation mitigates two issue raised . , threshold-value easier use interpret (see ). new implementation possible ZZ differs across trees. Yet also case original implementation, since predictors ZZ used splitting variable tree. addition, due randomness random forests (subsampling/bootstrapping mtry selection), unlikely two trees forest exactly splitting points. Therefore, conditional sampling scheme almost surely differs across trees.","code":""},{"path":"https://ddebeer.github.io/permimp/articles/permimp-package.html","id":"d--how-to-use-the-threshold-","dir":"Articles","previous_headings":"Part II: New Conditional Permutation Implementation","what":"D. How to Use the Threshold.","title":"The permimp-package","text":"threshold-value can interpreted tuning parameter make permutation less conditional. threshold = 0 threshold = 1 corresponding permuting conditional possible permuting completely unconditional, respectively. threshold = .95, default permimp, includes WW ZZ WdW_d XdX_d dependent (α\\alpha-level = .05). Yet threshold values smaller threshold = .5 generally make selection predictors condition greedy, without meaningful impact CPI pattern. Therefore, recommend using threshold values .5 1. research questions best answered marginal importance measure, questions better answered using partial importance measure. many situations, however, clear measure best fits research question. Therefore, argue cases can interesting evaluate importance (rankings) predictors different threshold-values. strategy can provide insight conditioning affects permutation importance values. original implementation, setting sensible threshold proved hard, practical meaning threshold depended sample size type variables (cf. issues raised ). new implementation, threshold’s interpretation clearer stable. addition, simulation studies Debeer Strobl (2020) suggest new implementation () allows gradual shift unconditional conditional; (b) gives stable importance measure computations. additional feature, permimp can provide diagnostics conditional permutation. thresholdDiagnostics = TRUE, permimp-function monitors whether conditional permutation scheme feasible predictor XX tree. information translated messages suggest either decrease threshold. First, possible conditioning grid fine-grained permuting XX conditionally lead observations ending different end-node tree. words, prediction accuracy permuting always equal. issue occurs 50 percent trees include XX splitting variable, permimp produce note, suggest increase threshold-value. higher threshold-value may result less fine-grained partitioning, making conditional permutation feasible . Second, possible WW tree χ2\\chi^2-independence test WdW_d XdX_d smaller (1 - threshold). implies ZZ empty set, conditionally permuting impossible. , without partitioning/grid, equal unconditionally permuting. issue occurs 50 percent trees include XX splitting variable, permimp produce note, suggest decrease threshold-value. lower threshold-value includes WW ZZ, making conditional permutation feasible .","code":""},{"path":[]},{"path":"https://ddebeer.github.io/permimp/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Dries Debeer. Author, maintainer. Torsten Hothorn. Author. Carolin Strobl. Author.","code":""},{"path":"https://ddebeer.github.io/permimp/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Debeer D, Hothorn T, Strobl C (2025). permimp: Conditional Permutation Importance. R package version 1.1.0.9000, https://ddebeer.github.io/permimp/.","code":"@Manual{,   title = {permimp: Conditional Permutation Importance},   author = {Dries Debeer and Torsten Hothorn and Carolin Strobl},   year = {2025},   note = {R package version 1.1.0.9000},   url = {https://ddebeer.github.io/permimp/}, }"},{"path":"https://ddebeer.github.io/permimp/index.html","id":"conditional-permutation-importance-for-random-forests","dir":"","previous_headings":"","what":"Conditional Permutation Importance","title":"Conditional Permutation Importance","text":"R-package computes Conditional Permutation Importance (CPI; Strobl, 2008) using alternative implementation faster stable (Debeer & Strobl 2020). (C)PI can computed random forest fit using () original impurity reduction method ( randomForest-package), (b) using Conditional Inference framework (party-package). addition, plotting method resulting VarImp-object included.","code":""},{"path":"https://ddebeer.github.io/permimp/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Conditional Permutation Importance","text":"package can installed using using devtools-package:","code":"install.packages(\"devtools\") devtools::install_github(\"ddebeer/permimp\")"},{"path":"https://ddebeer.github.io/permimp/index.html","id":"documentation","dir":"","previous_headings":"","what":"Documentation","title":"Conditional Permutation Importance","text":"workhorse permimp-function. documentation plotting function: {?plot.VarImp} ?plot.VarImp","code":"?permimp"},{"path":"https://ddebeer.github.io/permimp/index.html","id":"example","dir":"","previous_headings":"","what":"Example","title":"Conditional Permutation Importance","text":"","code":"library(party) library(randomForest) library(permimp)  ### set seed set.seed(542863)  ### get example data airq <- subset(airquality, !(is.na(Ozone) | is.na(Solar.R)))  ### fit a random forest ### ... using the party package cfAirq5 <- cforest(Ozone ~ ., data = airq,                     control = cforest_unbiased(mtry = 3, ntree = 1000,                                                minbucket = 5,                                                minsplit = 10))  ### compute the conditional permutation importance permimp_cf <- permimp(cfAirq5, conditional = TRUE) plot(permimp_cf, type = \"box\", interval = \"quantile\")   ### fit a random forest ... ### ... using the randomForest package rfAirq5 <- randomForest(Ozone ~ ., data = airq,                         mtry = 3, ntree = 1000, importance = TRUE,                         keep.forest = TRUE, keep.inbag = TRUE)  ### compute the conditional permutation importance permimp_rf <- permimp(rfAirq5, conditional = TRUE) plot(permimp_rf, horizontal = TRUE)"},{"path":"https://ddebeer.github.io/permimp/index.html","id":"parallel-processing","dir":"","previous_headings":"","what":"Parallel Processing","title":"Conditional Permutation Importance","text":"forests large trees parallel processing may speed computations. Parallel processing possible via cl argument. hood, pblapply function pbapply-package. Tip: using parallel processing set progressBar = FALSE. additional communication nodes updating progress bar slow computations.","code":""},{"path":"https://ddebeer.github.io/permimp/reference/VarImp-methods.html","id":null,"dir":"Reference","previous_headings":"","what":"Methods for VarImp Objects — VarImp-Methods","title":"Methods for VarImp Objects — VarImp-Methods","text":"Methods computing VarImp objects..","code":""},{"path":"https://ddebeer.github.io/permimp/reference/VarImp-methods.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for VarImp Objects — VarImp-Methods","text":"","code":"# S3 method for class 'VarImp' plot(x, nVar = length(x$values), type = c(\"bar\", \"box\", \"dot\", \"rank\"),                       sort = TRUE, interval = c( \"no\", \"quantile\", \"sd\"),                        intervalProbs = c(.25, .75), intervalColor = NULL,                        horizontal = FALSE, col = NULL, pch = NULL,                        main = NULL, margin = NULL, ...) # S3 method for class 'VarImp' print(x, ranks = FALSE, ...) # S3 method for class 'VarImp' subset(x, subset, ...)"},{"path":"https://ddebeer.github.io/permimp/reference/VarImp-methods.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Methods for VarImp Objects — VarImp-Methods","text":"x object class VarImp. nVar integer specifying number predictor variables                included plot. nVar predictor variables                highest variable importance measure retained. type character string indicates type plot. Must one                following: \"bar\", \"box\", \"dot\" \"rank\" (see Details). sort logical specifies whether predictors ranked according                importance measures. interval character string indicates , type intervals                    added plot. Must one following: \"\",                    \"quantile\", \"sd\" (see Details). intervalProbs numerical vector form c(bottom, top), specifying                         two quantiles used interval.                         meaningful interval = \"quantile\". intervalColor color code name, see par. horizontal logical specifies whether plot horizontal                      (= importance values x-axis. default FALSE. col color code name, see par. pch Either single character integer code specifying plotting               'character', see par. main overall title plot: see title. margin numerical vector form c(bottom, left, top, right),                  gives number lines margin specified                  four sides plot. See par. ranks logical specifying whether (reversed) rankings                 printed instead importance values. subset character, integer logical vector, specifying subset                   predictor variables. ... additional arguments.","code":""},{"path":"https://ddebeer.github.io/permimp/reference/VarImp-methods.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Methods for VarImp Objects — VarImp-Methods","text":"plot gives visualization variable importance values. print prints importance values, (reversed) rankings ranks = TRUE. ranks returns reversed rankings variable importance values. subset method VarImp objects returns VarImp object subset original predictors random forest. plot, type = \"bar\" results barplot, type = \"dot\" point-plot, type = \"rank\" point-plot importance rankings plotting 'characters', see ranks. three options interval (based either two quantiles standard deviation perTree values) can added plot. type = \"box\" results boxplots, meaningful perTree values available.","code":""},{"path":[]},{"path":"https://ddebeer.github.io/permimp/reference/VarImp-methods.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Methods for VarImp Objects — VarImp-Methods","text":"","code":"## Fit a random forest (using cforest)      set.seed(290875)   readingSkills.cf <- party::cforest(score ~ ., data = party::readingSkills,                                control = party::cforest_unbiased(mtry = 2, ntree = 50))      ## compute permutation variable importance:   set.seed(290875)   permVIM <- permimp(readingSkills.cf)      ## print the variable importance values   permVIM #> nativeSpeaker           age      shoeSize  #>      12.42492      76.58328      15.52237    print(permVIM, ranks = TRUE) #> Reversed ranking: 1 denotes the highest value.  #>  nativeSpeaker           age      shoeSize  #>             3             1             2    ranks(permVIM) #> Reversed ranking: 1 denotes the highest value.  #>   #> nativeSpeaker           age      shoeSize  #>             3             1             2       ## Visualize the variable importance values   plot(permVIM, type = \"bar\", margin = c(6,3,3,1))    plot(permVIM, nVar = 2, type = \"box\", horizontal = TRUE)       ## note the rankings   plot(subset(permVIM, c(\"age\", \"nativeSpeaker\")), intervalColor = \"pink\")    plot(subset(permVIM, c(\"shoeSize\", \"nativeSpeaker\")), intervalColor = \"pink\")"},{"path":"https://ddebeer.github.io/permimp/reference/VarImp.html","id":null,"dir":"Reference","previous_headings":"","what":"VarImp Objects — VarImp","title":"VarImp Objects — VarImp","text":"class random forest variable importance measures VarImp objects.","code":""},{"path":"https://ddebeer.github.io/permimp/reference/VarImp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"VarImp Objects — VarImp","text":"","code":"as.VarImp(object, ...)  ## S3 method for class 'data.frame' # S3 method for class 'data.frame' as.VarImp(object, FUN = mean,              type = c(\"Permutation\", \"Conditional Permutation\",                        \"Selection Frequency\", \"See Info\"),               info = NULL, ...)  ## S3 method for class 'matrix' # S3 method for class 'matrix' as.VarImp(object, FUN = mean,              type = c(\"Permutation\", \"Conditional Permutation\",                        \"Selection Frequency\", \"See Info\"),               info = NULL, ...)                ## S3 method for class 'numeric' # S3 method for class 'numeric' as.VarImp(object, perTree = NULL,                type = c(\"Permutation\", \"Conditional Permutation\",                         \"Selection Frequency\", \"See Info\"),                info = NULL, ...)                is.VarImp(VarImp)"},{"path":"https://ddebeer.github.io/permimp/reference/VarImp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"VarImp Objects — VarImp","text":"object R object. perTree matrix data frame size ntree x p containing               variable importance measures tree random forest. type character indicating type variable importance measure. info list additional information variable               importance measure. FUN function compute variable importance. See section 'Details'. VarImp object class VarImp. ... additional arguments.","code":""},{"path":"https://ddebeer.github.io/permimp/reference/VarImp.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"VarImp Objects — VarImp","text":".VarImp creates object class 'VarImp'. object               matrix data.frame, final values               computed applying FUN columns. .VarImp               returns logical indicating whether evaluated object class               'VarImp'.","code":""},{"path":[]},{"path":"https://ddebeer.github.io/permimp/reference/VarImp.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"VarImp Objects — VarImp","text":"","code":"## Matrix of fake importance measures per Tree     set.seed(290875)   ntree <- 500   p <- 15   fakeVIM <- matrix(rnorm(ntree * p), nrow = ntree, ncol = p,                     dimnames = list(paste0(\"pred\", seq_len(ntree)), paste0(\"pred\", seq_len(p))))   is.VarImp(fakeVIM) #> [1] FALSE      ## make a 'VarImp' object   fakeVarImp <- as.VarImp(fakeVIM, type = \"See Info\",                      info = list(\"The Vims are based on fake data.\",                      \"The mean was used to aggregate across the trees\"))    is.VarImp(fakeVarImp) #> [1] TRUE"},{"path":"https://ddebeer.github.io/permimp/reference/permimp-package.html","id":null,"dir":"Reference","previous_headings":"","what":"Conditional Permutation Importance — permimp-package","title":"Conditional Permutation Importance — permimp-package","text":"add-'party' package, faster implementation    partial-conditional permutation importance random forests.    standard permutation importance implemented exactly    'party' package. conditional permutation importance can    computed faster, option backward compatible 'party'    implementation. package compatible random forests fit using    'party' 'randomForest' package. methods described    Strobl et al. (2007) <doi:10.1186/1471-2105-8-25>    Debeer Strobl (2020) <doi:10.1186/s12859-020-03622-2>.","code":""},{"path":"https://ddebeer.github.io/permimp/reference/permimp-package.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Conditional Permutation Importance — permimp-package","text":"Index:  package yet installed build time.","code":""},{"path":"https://ddebeer.github.io/permimp/reference/permimp-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Conditional Permutation Importance — permimp-package","text":"Maintainer: Dries Debeer dries.debeer@uzh.ch Authors: Carolin Strobl Torsten Hothorn","code":""},{"path":"https://ddebeer.github.io/permimp/reference/permimp.html","id":null,"dir":"Reference","previous_headings":"","what":"Random Forest Permutation Importance for random forests — permimp","title":"Random Forest Permutation Importance for random forests — permimp","text":"Standard partial/conditional permutation importance     random forest-objects fit using party randomForest     packages, following permutation principle `mean decrease     accuracy' importance randomForest . partial/conditional permutation     importance implemented differently, selecting predictions condition     tree using Pearson Chi-squared tests applied     -split point-categorized predictors. general new implementation     similar results original varimp function.     asParty = TRUE, partial/conditional permutation importance     fully backward-compatible faster original varimp     function party.","code":""},{"path":"https://ddebeer.github.io/permimp/reference/permimp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Random Forest Permutation Importance for random forests — permimp","text":"","code":"permimp(object, ...) # S3 method for class 'randomForest' permimp(object, nperm = 1, OOB = TRUE, scaled = FALSE,      conditional = FALSE, threshold = .95, whichxnames = NULL,         thresholdDiagnostics = FALSE, progressBar = interactive(), do_check = TRUE,       oldSeedSelection = FALSE, cl = NULL, ...) # S3 method for class 'RandomForest' permimp(object, nperm = 1, OOB = TRUE, scaled = FALSE,      conditional = FALSE, threshold = .95, whichxnames = NULL,         thresholdDiagnostics = FALSE, progressBar = interactive(),       pre1.0_0 = conditional, AUC = FALSE, asParty = FALSE, mincriterion = 0,       oldSeedSelection = FALSE, cl = NULL, ...)"},{"path":"https://ddebeer.github.io/permimp/reference/permimp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Random Forest Permutation Importance for random forests — permimp","text":"object object returned cforest randomForest. mincriterion value test statistic 1 - p-value                        must exceeded order include split                        computation importance. default                        mincriterion = 0 guarantees splits                        included. conditional logical determines whether unconditional conditional                       permutation performed. threshold threshold value (1 - p-value) association                     predictor interest another predictor,                     must exceeded order include predictor                     conditioning scheme predictor interest (                    relevant conditional = TRUE). threshold value                     zero includes predictors. nperm number permutations performed. OOB logical determines whether importance computed               --bag sample learning sample (suggested). pre1.0_0 Prior party version 1.0-0, actual data values                    permuted according original permutation                    importance suggested Breiman (2001). Now assignments                    child nodes splits variable interest                    permuted described Hapfelmeier et al. (2012),                    allows missing values predictors                    efficient respect memory consumption                    computing time. method apply conditional                    permutation importance, random forests                    fit using party package. scaled logical determines whether differences prediction                  accuracy scaled total (null-model) error. AUC logical determines whether Area Curve (AUC)               instead accuracy used compute permutation \t\t\t  importance (cf. Janitza et al., 2012). AUC-based permutation \t\t\t  importance robust towards class imbalance, \t\t\t  applicable binary classification. asParty logical determines whether exactly                   values original varimp function \t\t\t\t  party obtained. whichxnames character vector containing predictor variable                       names permutation importance \t\t\t\t\t  computed. use aware implications, see \t\t\t\t\t  section 'Details'. thresholdDiagnostics logical specifies whether diagnostics                                respect threshold-value \t\t\t\t\t\t\t   prompted warnings. progressBar logical determines whether progress bar                       displayed. do_check logical determines whether check requiring user                    input included. oldSeedSelection logical determines whether selection                            random numbers 1.1                            version package. default FALSE,                            seeds generated tree,                            results reproducible, also parallel processing                            used. cl cluster object created makeCluster,              integer indicate number child-processes (integer values              ignored Windows) parallel evaluations (see Details              parallel computing). NULL (default) refers sequential              evaluation. ... additional arguments passed Methods","code":""},{"path":"https://ddebeer.github.io/permimp/reference/permimp.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Random Forest Permutation Importance for random forests — permimp","text":"Function permimp highly comparable varimp party,   partial/conditional variable importance different, efficient   implementation. Compared original varimp party,   permimp applies different strategy select predictors condition   (ADD REFERENCE PAPER). asParty = TRUE, permimp returns exactly values   varimp party, computation done efficiently. conditional = TRUE, importance variable computed   permuting within grid defined predictors associated   (1 - p-value greater threshold) variable interest.   threshold can interpreted parameter moves permutation   importance across dimension fully conditional (threshold = 0)   completely unconditional (threshold = 1), see Debeer Strobl (2020). Using wichxnames argument, computation permutation importance   can limited smaller number specified predictors. Note, however,   conditional = TRUE, () predictors condition also   limited selection predictors. use fully aware   implications. parallel processing, pbapply package, wrapper around parallel   package used. Parallel processing can enabled cl   argument.  parLapply called cl 'cluster'   object, mclapply called cl integer. parallel processing, objects might need pushed   workers, random numbers must handled care (see Examples   pbapply package). using parallel processing, showing progress bar increases   communication overhead main process nodes / child processes   compared parallel equivalents functions without progress bar.   functions fall back original equivalents   progressBar = FALSE. default interactive()   FALSE (.e. called command line R script) details, please refer documentation varimp.","code":""},{"path":"https://ddebeer.github.io/permimp/reference/permimp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Random Forest Permutation Importance for random forests — permimp","text":"object class varimp, mean decrease accuracy     $values.","code":""},{"path":"https://ddebeer.github.io/permimp/reference/permimp.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Random Forest Permutation Importance for random forests — permimp","text":"Leo Breiman (2001). Random Forests. Machine Learning, 45(1), 5–32. Alexander Hapfelmeier, Torsten Hothorn, Kurt Ulm, Carolin Strobl (2012).     New Variable Importance Measure Random Forests Missing Data.     Statistics Computing, https://link.springer.com/article/10.1007/s11222-012-9349-1 Torsten Hothorn, Kurt Hornik, Achim Zeileis (2006b). Unbiased     Recursive Partitioning: Conditional Inference Framework.     Journal Computational Graphical Statistics, 15 (3),     651-674.  Preprint available     https://www.zeileis.org/papers/Hothorn+Hornik+Zeileis-2006.pdf Silke Janitza, Carolin Strobl Anne-Laure Boulesteix (2013). AUC-based     Permutation Variable Importance Measure Random Forests.     BMC Bioinformatics.2013, 14 119.     https://bmcbioinformatics.biomedcentral.com/articles/10.1186/1471-2105-14-119 Carolin Strobl, Anne-Laure Boulesteix, Thomas Kneib, Thomas Augustin,     Achim Zeileis (2008). Conditional Variable Importance Random Forests.     BMC Bioinformatics, 9, 307.     https://bmcbioinformatics.biomedcentral.com/articles/10.1186/1471-2105-9-307 Debeer Dries Carolin Strobl (2020). Conditional Permutation Importance     Revisited. BMC Bioinformatics, 21, 307.     https://bmcbioinformatics.biomedcentral.com/articles/10.1186/s12859-020-03622-2","code":""},{"path":[]},{"path":"https://ddebeer.github.io/permimp/reference/permimp.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Random Forest Permutation Importance for random forests — permimp","text":"","code":"### for RandomForest-objects, by party::cforest()     set.seed(290875)   readingSkills.cf <- party::cforest(score ~ ., data = party::readingSkills,                                control = party::cforest_unbiased(mtry = 2, ntree = 25))      ### conditional importance, may take a while...   # party implementation:   set.seed(290875)   party::varimp(readingSkills.cf, conditional = TRUE) #> nativeSpeaker           age      shoeSize  #>     11.060828     47.984469      1.457061    # faster implementation but same results   set.seed(290875)   permimp(readingSkills.cf, conditional = TRUE, asParty = TRUE) #> nativeSpeaker           age      shoeSize  #>     11.060828     47.984469      1.457061       # different implementation with similar results   set.seed(290875)   permimp(readingSkills.cf, conditional = TRUE, asParty = FALSE) #> nativeSpeaker           age      shoeSize  #>     12.640102     50.529059      1.532613       ### standard (unconditional) importance is unchanged   set.seed(290875)   party::varimp(readingSkills.cf) #> nativeSpeaker           age      shoeSize  #>      12.40733      73.35346      20.63118    set.seed(290875)   permimp(readingSkills.cf, oldSeedSelection = TRUE) #> nativeSpeaker           age      shoeSize  #>      12.40733      73.35346      20.63118          ###   set.seed(290875)   readingSkills.rf <- randomForest::randomForest(score ~ ., data = party::readingSkills,                                mtry = 2, ntree = 25, importance = TRUE,                                keep.forest = TRUE, keep.inbag = TRUE)                                       ### (unconditional) Permutation Importance   set.seed(290875)   permimp(readingSkills.rf, do_check = FALSE) #> nativeSpeaker           age      shoeSize  #>      17.75154      85.57181      12.78995       # very close to   readingSkills.rf$importance[,1] #> nativeSpeaker           age      shoeSize  #>      17.65385      82.11491      13.86879       ### Conditional Permutation Importance   set.seed(290875)   permimp(readingSkills.rf, conditional = TRUE, threshold = .8, do_check = FALSE) #> nativeSpeaker           age      shoeSize  #>   14.19811819   15.16896923   -0.01609468                                   if (FALSE) { # \\dontrun{   ### Parallel processing - Windows   # Only relevant for large trees, for small trees, there may not even be a    # 'speed up', but a 'slow down'      # Make a larger forest   set.seed(290875)   readingSkills.cf <- party::cforest(score ~ ., data = party::readingSkills,                                       control = party::cforest_unbiased(mtry = 2,                                                                         ntree = 200))      # sequentiall processing   set.seed(290875)   system.time(print(permimp(readingSkills.cf, conditional = TRUE, asParty = FALSE)))      # parallel processing   # note that the results are reproducible despite using multiple cores   cluster <- parallel::makeCluster(2)    set.seed(290875)   system.time(print(permimp(readingSkills.cf, conditional = TRUE,                              asParty = FALSE, cl = cluster, progressBar = FALSE)))   parallel::stopCluster(cluster)   } # }"},{"path":"https://ddebeer.github.io/permimp/reference/ranks.html","id":null,"dir":"Reference","previous_headings":"","what":"Reversed Rankings — ranks","title":"Reversed Rankings — ranks","text":"Method giving reversed rankings numerical values vector VarImp object.","code":""},{"path":"https://ddebeer.github.io/permimp/reference/ranks.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Reversed Rankings — ranks","text":"","code":"ranks(x, note = TRUE, ...) # Default S3 method ranks(x, note = TRUE, ...) # S3 method for class 'VarImp' ranks(x, note = TRUE, ...)"},{"path":"https://ddebeer.github.io/permimp/reference/ranks.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Reversed Rankings — ranks","text":"x object reverse ranked. note logical specifying whether (reversed) rankings                printed instead importance values. ... additional arguments passed rank.","code":""},{"path":"https://ddebeer.github.io/permimp/reference/ranks.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Reversed Rankings — ranks","text":"ranks function nothing   (length(x) - rank(x, ...) + 1L). also works objects class   VarImp.","code":""},{"path":"https://ddebeer.github.io/permimp/reference/ranks.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Reversed Rankings — ranks","text":"vector containing reversed rankings.","code":""},{"path":"https://ddebeer.github.io/permimp/reference/ranks.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Reversed Rankings — ranks","text":"","code":"## High Jump data   HighJumps <- c(Anna = 1.45, Betty = 1.53, Cara = 1.37, Debby = 1.61,                   Emma = 1.29, Hanna = 1.44, Juno = 1.71)   HighJumps #>  Anna Betty  Cara Debby  Emma Hanna  Juno  #>  1.45  1.53  1.37  1.61  1.29  1.44  1.71    ## ranking of high jump data   ranks(HighJumps) #> Reversed ranking: 1 denotes the highest value.  #>   #>  Anna Betty  Cara Debby  Emma Hanna  Juno  #>     4     3     6     2     7     5     1"},{"path":"https://ddebeer.github.io/permimp/reference/selFreq.html","id":null,"dir":"Reference","previous_headings":"","what":"Predictor Selection Frequency in Random Forests — selFreq","title":"Predictor Selection Frequency in Random Forests — selFreq","text":"counts many times predictor variable selected splitting     random forest. implemented cforest form party     package.","code":""},{"path":"https://ddebeer.github.io/permimp/reference/selFreq.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Predictor Selection Frequency in Random Forests — selFreq","text":"","code":"selFreq(object, whichxnames = NULL)"},{"path":"https://ddebeer.github.io/permimp/reference/selFreq.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Predictor Selection Frequency in Random Forests — selFreq","text":"object object returned cforest. whichxnames character vector containing predictor variable names                   permutation importance computed. See section 'Details'.","code":""},{"path":"https://ddebeer.github.io/permimp/reference/selFreq.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Predictor Selection Frequency in Random Forests — selFreq","text":"Function selFreq counts many times predictor variable   selected splitting random forest. current implementation   selFreq can applied random forests returned   cforest.","code":""},{"path":"https://ddebeer.github.io/permimp/reference/selFreq.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Predictor Selection Frequency in Random Forests — selFreq","text":"object class VarImp, $values mean   sum selection frequencies across trees.","code":""},{"path":[]},{"path":"https://ddebeer.github.io/permimp/reference/selFreq.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Predictor Selection Frequency in Random Forests — selFreq","text":"","code":"set.seed(290875)   readingSkills.cf <- party::cforest(score ~ ., data = party::readingSkills,                                control = party::cforest_unbiased(mtry = 2, ntree = 100))      ## Selection Frequency   selFreq(readingSkills.cf) #> nativeSpeaker           age      shoeSize  #>          2.50          4.50          1.74"},{"path":[]},{"path":"https://ddebeer.github.io/permimp/news/index.html","id":"permimp-12-0","dir":"Changelog","previous_headings":"","what":"permimp 1.2-0","title":"permimp 1.2-0","text":"implemented parallel processing using pbapply-package implemented random seed selection per tree reproducibility reasons. backward compatibility, argument “oldSeedSelection = TRUE” can used","code":""},{"path":"https://ddebeer.github.io/permimp/news/index.html","id":"permimp-10-2","dir":"Changelog","previous_headings":"","what":"permimp 1.0-2","title":"permimp 1.0-2","text":"CRAN release: 2021-09-13 Testing issue solved.","code":""},{"path":"https://ddebeer.github.io/permimp/news/index.html","id":"permimp-10-1","dir":"Changelog","previous_headings":"","what":"permimp 1.0-1","title":"permimp 1.0-1","text":"CRAN release: 2021-02-11 Bug fix permimp(…, AUC = TRUE), found Ilia Ogol","code":""},{"path":"https://ddebeer.github.io/permimp/news/index.html","id":"permimp-10-0","dir":"Changelog","previous_headings":"","what":"permimp 1.0-0","title":"permimp 1.0-0","text":"CRAN release: 2020-06-25 First release.","code":""}]
